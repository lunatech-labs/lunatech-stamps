Due to conflicts with Play! templates the tags are defined like this:

~{tag /} or ~{tag}{/tag}
!{ JS statements }!
^{ JS expressions inserted in the body }
`{ JS expression that is saved during template expansion, to be used in later JS code }

Use a JSTemplates.Future instance to delay evaluation in the @future@ tag.

See examples in /app/views/Application/index.html, /public/templates/t1.html and /app/views/Application/facebook.html for a full-fledged AJAX application. 

h1. Using templates

h2. Procedural style

<pre><code><div id="output"></div>
<script>
	// Those will replace the content of #output with the result of the template evaluation
	// for a remote template
	JSTemplates.loadTemplate("output", {url: "/public/templates/t1.html"}, /* optional */ {value: "foo"});
	// for a template reference
	JSTemplates.loadTemplate("output", {id: "my-template"}, /* optional */ {value: "foo"});
	
	// Or if you just want the html:
	var html = JSTemplates.applyTemplate("my-template", /* optional */ {value: "foo"});
</script>
</code></pre>

h2. jQuery plugin style

<pre><code><div id="output2"></div>
<script>
	// for a remote template
	jQuery("#output2").jsTemplates({url: "/public/templates/t1.html"}, /* optional */ {value: "foo"});
	// for a template reference
	jQuery("#output2").jsTemplates({id: "my-template"}, /* optional */ {value: "foo"});
</script>
</code></pre>

h2. Declarative style

<pre><code><div data-jstemplate-url="/public/templates/t1.html"></div>
</code></pre>

h2. Inline style

<pre><code><script data-jstemplate="inline" type="text/html">
 ... template data ...
</script>
</code></pre>

h2. Declaring a template reference

<pre><code><script id="my-template" data-jstemplate="ref" type="text/html">
 ... template data ...
</script>
</code></pre>

h1. Writing templates

h2. Statement blocks

Write JS statements (to declare variables for example) like this:

<pre><code> !{ var foo = callthis(); }!
</code></pre>

h2. Expression blocks

Write JS expressions to be inserted in the page like this:

<pre><code> ^{ foo > 2 ? foo + 23 : foo }
</code></pre>

h2. Dynamic blocks

Write JS expressions that should be injected as JS values for JS code in the page like this:

<pre><code> <a onclick="`{ user.save }()">Click me</a>
</code></pre>

This is very useful for exposing values which exist during template evaluation as values that can be used in the generated JS code itself.

h2. Tags

Tags can either have a body:

<pre><code> ~{tag}...~{/tag}
</code></pre>

Or they can have no body:

<pre><code>
 ~{tag/}
</code></pre>

There are a number of defined tags, and you can write your own if you want.

h3. If tag

The @if@ tag allows you to write conditional templates:

<pre><code> ~{if foo == 42}Foo is the answer~{/if}
</code></pre>

The @else@ tag allows you to add a default condition to the @if@ tag:

<pre><code> ~{if foo == 42}Foo is the answer~{/if}
 ~{else foo == 42}Foo is NOT the answer~{/else}
</code></pre>

h3. List tag

The @list@ tag allows you to write iterative templates:

<pre><code> <ul>
 ~{list items: [1,2,3], var: 'v'}
  <li>Value of v is: ^{v}</li>
 ~{/list}
 </ul>
</code></pre>

h3. Timer tag

The @timer@ tag allows you to reevaluate the body every @X@ milliseconds:

<pre><code>~{timer 1}
 Time is ^{new Date().toLocaleString()}
~{/timer}
</code></pre>

This will produce text that is replaced every 1 second with a new template evaluation result.

h3. Future tag

The @future@ tag allows you to delay template evaluation until the given Future is defined.

When doing AJAX it's likely you'll have some templates that will depend on external data which you load using AJAX, which means it's going to be asynchronous.

In JSTemplates we use _futures_ to describe values that might or might not yet be defined (because they could arrive later via AJAX). When you pass the @future@ tag a value which is an instance of the type @JSTemplates.Future@, the current template tag evaluation is delayed until the _future_ instance is defined fully (when it receives its value from the network, for instance), and the current template is _partially_ evaluated, leaving gaps (actually, placeholders) where the template tags are waiting for _futures_.

Once the _future_ instances are complete, the template processing is resumed with the _future_'s value and the placeholders are replaced with the evaluation of the delayed templates.

This makes it very easy to define a complete page with _holes_ for the parts which rely on external data, without delaying the rendering of the rest of the templates.

You can define a _future_ which gets JSON data from an external source like this:

<pre><code>~{future value:new JSTemplates.Future("/Application/data"), var:'elements' }
 <ul>
 ~{list items: elements, var: 'v'}
  <li>Value of v is: ^{v}</li>
 ~{/list}
 </ul>
~{/future}
</code></pre>

Note that you can define your own subclasses of @JSTemplate.Future@ to define new types of ways to get to asynchronous data.

h2. Writing your own tag

h3. Simple tags

You can declare your simple tags like this:

<pre><code>
 <script jstemplate="tag" name="hello" type="text/html">
  Hello ^{_arg}!
 </script>
</code></pre>

And then invoke it later on with:

<pre><code> <script jstemplate="inline" type="text/html">
  #{hello 'World'/}
 </script>
</code></pre>

Or procedurally:

<pre><code><div id="output"></div>
<script>
	// Those will replace the content of #output with the result of the template evaluation
	// for a template reference
	JSTemplates.loadTemplate("output", {id: "hello"}, {_arg: "World"});
	
	// Or if you just want the html:
	var html = JSTemplates.applyTemplate("hello", {_arg: "World"});
</script>
</code></pre>

Which will produce @Hello World!@.

If you pass a single unnamed parameter it will be named @_arg@ but you can also explicitely name them (in which case they should be accessed with a leading underscore) and even pass in a body to be expanded with the @doBody@ tag:

<pre><code> <script jstemplate="tag" name="hello" type="text/html">
  Hello ^{_firstName} "~{doBody/}" ^{_lastName}!
 </script>

 <script jstemplate="inline" type="text/html">
  #{hello firstName: 'Stef', lastName: 'Epardaud'}
   FroMage
  #{/hello}
 </script>
</code></pre>

Which will produce @Hello Stef "FroMage" Epardaud!@.

h3. Coding your own tag

You must define a subtype of @JSTemplates.Tag@, and register it for JSTemplates to find:

<pre><code>// define our new tag type
function HelloTag(name, attributes){
	JSTemplates.Tag.apply(this, [name, attributes]);
}
// make sure it inherits methods from JSTemplates.Tag
JSTemplates.extend(HelloTag, JSTemplates.Tag);

// and implement its behaviour
HelloTag.prototype.outputInNewEnv = function(out, previousSibling, env){
	// when we do not name the attributes, the default is "_arg"
	// we evaluate the contents of the attribute in the current environment
	var string = env.evalExpression(this.attributes._arg);
	// and we write it out
	out('Hello ' + string);
};

// register this new tag in JSTemplates
JSTemplates.declareTag('hello', HelloTag);
</code></pre>

You can now use this tag as such:

<pre><code>~{hello 'World!' /}
</code></pre>

Which will produce @Hello World!@ :)

