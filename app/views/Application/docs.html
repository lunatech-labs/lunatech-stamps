#{extends 'main.html' /}
#{set title:'JSTemplates docs' /}
#{set 'moreScripts'}
<script src="@{'/public/scripts/less.js'}" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript">

    function hsf(){return $(".toc ul").height()+24}
    
    function adjustToc(){
        var hs = hsf();
        $(".toc").animate({
            height: hs
            }, 'fast');
        $("#site").animate( { marginTop: hs+24 }, 'fast' );
    }
    function pageMe(h){
        var l = $("#link-"+h);
        var h = $("#"+h);
        var p = h.closest(".para");
        if(p.is(":hidden")) {
            $(".para").hide();
            p.show();
        } 
        $(".active").removeClass("active");
        h.addClass('active');
        l.addClass('active');
        $("body").eq(0).scrollTop((h.offset()).top - (hsf()+24));
        slideToc(l);
    }
    
    function slideToc(l){
        var li = l.closest('li');
        if(li.is(".level2")){
            li.nextUntil(".level1").andSelf().slideDown();
            li.prevUntil(".level1").andSelf().slideDown(function(){adjustToc()});
        } else {
            $(".level2:visible").slideUp();
            li.nextUntil(".level1").slideDown(function(){adjustToc()});
        }
    }
    
    window.onload = init;
    function init(){
        $(".toc, h1").css("position","fixed");
        var h = location.hash.split("/")[1];
        if (h==undefined) {
            $(".toc li:first a").trigger('click');
        } else {
            $("#link-"+h).eq(0).trigger('click');
        }
        adjustToc();
    }
    
</script>
#{/set}
#{set 'moreStyles'}
 <link rel="stylesheet/less" type="text/css" media="screen" href="@{'/public/styles/jstemplates/less/docs.less'}">
#{/set}

<script data-jstemplate="inline" type="text/html">
 <div class="toc">
  <ul>
  ~{jQuery selector: ".para .title, h3", var: 'el'}
   !{ 
     var t = el.text();
     var a = t.replace(/\?/gi,"").replace(/\s/gi,"-").toLowerCase();
     el.attr('id', a);
   }!
   <li class="^{el.is('h3') ? 'level2': 'level1'}"><a href="#!/^{a}" id="link-^{a}" onclick="pageMe('^{a}')">^{t}</a></li>
  ~{/jQuery}
  </ul>

 </div>
</script>

<h1>
 <a href="/application/docs" class="product-name"><span>JS</span>Templates*</a>
 <div class="tagline">*Client-side templates for an easy life</div>
</h1>

<div class="para">
 <h2 class="title">What is JSTemplates?</h2>
 <div class="body">
  <p>
  JSTemplates is a client-side templating library similar to Play! Framework's server-side Groovy templates,
  but on the client, in pure JavaScript.
  </p>
  
  <h3>Why not user server-side templates?</h3>
  
  <p>
   With server-side templates, you serve pages by loading data from the database, then produce HTML pages
   using templates, then ship those pages to the client. This has the following drawbacks:
  </p>
  
  <ul>
   <li><p>
     Template-processing uses CPU time which can impact scaling. On the other hand, the clients often have
     multi-core CPUs doing nothing most of the time. We can distribute the cost of rendering pages to the clients.
   </p></li>
   <li><p>
     Generating pages on the server increases the bandwidth necessary to serve pages, since we're sending a lot
     of HTML that is generated from data we load from the database. If we can send the data directly to the client
     and the client can generate the HTML, we can gain on bandwidth to serve the pages.
   </p></li>
   <li><p>
     If you generate a list of items on the server using templates, it is hard to add elements to that list on
     the client using AJAX, because the rendering logic is on the server, which means you have to duplicate it
     on the client.
   </p></li>
  </ul>
  
  <p>
   Add to that the fact that when doing AJAX, you always end up creating lots of HTML on the client using ad-hoc
   means, most of the time either DOM manipulation or using jQuery, and that leads to ugly clumbsy code that is
   hard to maintain. This is the exact reason why the servers switched from that sort of rendering to templating
   long ago, which is still largely unused on the client, unfortunately.
  </p>

  <h3>Why can client-side templates do for me?</h3>
  
  <p>
   In addition to all the benefits we already discussed, client-side templates bring a number of unique features
   that are not possible on server-side templates: 
  </p>

  <ul>
   <li><p>
    Template expressions and statements written in JavaScript, and not a dreadful sub-language such as UEL or
    a third language such as Groovy (supposing the server is written in Java and the client in JavaScript).
   </p></li>
   <li><p>
    The ability to introduce dynamic elements in the template, such as futures (parts of the template whose rendering
    is delayed until a certain resource arrives from the server in the background) or timed updates (being able
    to re-render parts of a template at specific time intervals), or even being able to use template evaluation-time
    values at run-time (functions produced by the template, used in <i>onclick</i> handlers).
   </p></li>
   <li><p>
    Define new template tags for new behaviour, either programatically for complex behaviour, or declaratively by
    simply giving a name to a template part.
   </p></li>
   <li><p>
    Apply templates on a page automatically, or by invoking an API for dynamic updates.
   </p></li>
  </ul>
 </div>
</div>

<script type="text/javascript">
 var example = 1;
</script>

<script name="example" data-jstemplate="tag" type="text/html">
  <table class="example">
   <tr>
    <th class="program">JSTemplates</th>
    <th class="result">Result source</th>
    <th>Result</th>
   </tr>
   <tr>
   <td class="program">
    <code><pre>~{doBody escape: true/}</pre></code>
    <script id="ex^{example}" type="text/html">~{doBody/}~{closeScript/}
   </td>
   <td class="result">
    <script type="text/javascript">
     var template = jQuery("#ex^{example}").html();
     console.log("got template" + template);
     var result = JSTemplates.__processTemplates(template);
     result = result.replace(/\n( *\n)+/g, "\n");
     jQuery("#ex^{example}-res").text(result);
     jQuery("#ex^{example}-res-eval").html(result);
    ~{closeScript/}
    <code><pre id="ex^{example}-res"></pre></code>
   </td>
   <td class="result-eval" id="ex^{example}-res-eval">
   </td>
  </tr>
 </table>
 !{ example++; }!
</script>

<div class="para">
 <h2 class="title">Templates examples</h2>
 <div class="body">
  <h3>Expressions</h3>
  <p>
  Here is our first example of using JSTemplates where we use the <tt>^{ expr }</tt> notation to inject the result
  of a JavaScript expression in the template result:
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}Here is the current date: 
^{new Date().toLocaleString()}~{/noEval}~{/example}
  </script>

  <h3>Tags</h3>
  <p>
   Tags in JSTemplates are invoked with the <tt>~{ tag attr: val, attr: val... }</tt> notation and closed with
   <tt>~{/ tag }</tt> and can be used for complex behaviour such as iterating lists:
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}<ul>
 ~{list items: [1,2,3,4,5], var: 'i'}
  <li>Item ^{i}</li>
 ~{/list}
</ul>~{/noEval}~{/example}
  </script>
  <p>
   There are a number of predefined tags, and of course you can define your own tags easily, which we will see later.
  </p>

  <h3>Code blocks</h3>
  <p>
   Code blocks are very powerful in JSTemplates since they allow you to execute JavaScript statements during
   template evaluation. They are defined with <tt>!{ statement... }!</tt> notation:
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}!{ var count = 0; }!
<ul>
 ~{list items: [1,2,3,4,5], var: 'i'}
  !{ count++; }!
  <li>Item ^{i}</li>
 ~{/list}
</ul>
Total: ^{count}~{/noEval}~{/example}
  </script>

  <h3>Dynamic expressions</h3>
  <p>
   Dynamic expressions let you use expressions defined at template-evaluation time in the code that is
   executed at run-time. The most common usage is to define (or get a hold of) a function at template-evaluation
   time, and want to be able to call this function as an <i>onclick</i> handler in the generated HTML. You write
   this with this syntax: <tt>`{ expression }</tt>.
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}<ul>
 ~{list items: [1,2,3,4,5], var: 'i'}
  <li>
   !{
     var f = function(){ 
      alert(i);
      return false;
     }
   }!
   <a href="#" 
      onclick="return `{f}();"
     >Click me</a>
  </li>
 ~{/list}
</ul>~{/noEval}~{/example}
  </script>
 </div>
</div>

<div class="para">
 <h2 class="title">Invoking templates</h2>
 <div class="body">
  <h3>Inline</h3>
  <p>
   Any <tt>script</tt> elements of type <tt>text/html</tt>, with the <tt>data-jstemplate</tt> 
   attribute set to <tt>inline</tt> will be evaluated by JSTemplates and replaced inline:
  </p>
  <table class="example">
   <tr>
    <th class="program">HTML</th>
    <th>Result</th>
   </tr>
   <tr>
   <td class="program">
    <code><pre>&lt;script type="text/html" data-jstemplate="inline">
 ^{new Date().toLocaleString()}
&lt;/script>
</pre></code>
   </td>
   <td class="result">
    <script type="text/html" data-jstemplate="inline">
     ^{new Date().toLocaleString()}
    </script>
   </td>
  </tr>
 </table>

  <h3>Invoke programmatically</h3>
  <p>
   You can invoke any simple tag programmatically and replace an element with the template's output, or just
   retrieve the template output. An optional argument contains the initial environment of the template, where
   you can pass any JavaScript values that will be visible inside the template (on top of the JavaScript global
   scope).
  </p>
  <table class="example">
   <tr>
    <th class="program">HTML</th>
   </tr>
   <tr>
   <td class="program">
    <code><pre>&lt;script type="text/javascript">
	// Those will replace the content of #output with the result of the template evaluation
	// for a template reference
	JSTemplates.loadTemplate("output", {id: "hello"}, /* optional */ {_arg: "World"});
	
	// Or using the jQuery plugin:
	jQuery("#output").jsTemplates({id: "hello"}, /* optional */ {_arg: "World"});
	
	// Or if you just want the html:
	var html = JSTemplates.applyTemplate("hello", /* optional */ {_arg: "World"});
&lt;/script>
</pre></code>
   </td>
   </tr>
  </table>
 </div>
</div>

<script name="doc" data-jstemplate="tag" type="text/html">
  <table class="doc">
   <tr class="tag">
    <th>Tag</th>
    <td>^{_tag}</td>
   </tr>
   ~{if _attributes}
    ~{list items: Object.keys(_attributes), var: 'attr'}
     <tr class="attribute">
      <th>Attribute ^{attr}</th>
      <td>^{_attributes[attr]}</td>
    </tr>
    ~{/list}
   ~{/if}
   ~{if _attribute}
   <tr class="attribute">
    <th>Attribute</th>
    <td>^{_attribute}</td>
   </tr>
   ~{/if}
   <tr class="body">
    <th>Body</th>
    <td>^{_body ? 'required' : 'no'}</td>
   </tr>
   <tr class="doc">
    <th>Description</th>
    <td>~{doBody/}</td>
   </tr>
 </table>
</script>


<div class="para">
 <h2 class="title">Predefined tags</h2>
 <div class="body">
  <script data-jstemplate="inline" type="text/html">
    ~{doc tag: 'if', attribute: 'boolean expression', body: true}
     If the boolean expression evaluates to a <i>truish</i> value, the body of the tag is evaluated. Otherwise
     it is discarded. 
    ~{/doc}
  </script>
  <h3>if</h3>
  <p>
   Write conditionals with the <tt>if</tt> tag.
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}~{if 1 == 2}
 This is false.
~{/if}

~{if true}
 This is true.
~{/if}
~{/noEval}~{/example}
  </script>

  <script data-jstemplate="inline" type="text/html">
    ~{doc tag: 'else', body: true}
     If the previous <tt>if</tt> tag's boolean expression evaluates to a <i>false</i> value, the body of the 
     tag is evaluated. Otherwise it is discarded. 
    ~{/doc}
  </script>
  <h3>else</h3>
  <p>
   Optional tag to go with the <tt>if</tt> tag.
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}~{if 1 == 2}
 This is false.
~{/if}
~{else}
 One is not two.
~{/else}

~{if true}
 This is true.
~{/if}
~{else}
 The test failed.
~{/else}
~{/noEval}~{/example}
  </script>

  <script data-jstemplate="inline" type="text/html">
    ~{doc tag: 'list', 
          attributes: {items: 'An array expression to iterate', 
                       var: 'The name of the variable to hold each iterated item'}, 
          body: true}
     Evaluates the body once for each item in the <tt>items</tt> attribute, each time defining the
     <tt>var</tt> variable to hold the iterated element. An extra <tt>var_index</tt> variable is defined
     to hold the current iteration number.
    ~{/doc}
  </script>
  <h3>list</h3>
  <p>
   Iterate over arrays with the <tt>list</tt> tag.
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}<ul>
 ~{list items: ["blue","green","red"], 
        var: "color"}
  <li>^{color_index}: ^{color}</li>
 ~{/list}
</ul>~{/noEval}~{/example}
  </script>

  <script data-jstemplate="inline" type="text/html">
    ~{doc tag: 'jQuery', 
          attributes: {selector: 'A jQuery selector to iterate', 
                       var: 'The name of the variable to hold each iterated item'}, 
          body: true}
     Evaluates the body once for each item that matches the jQuery <tt>selector</tt> attribute, 
     each time defining the <tt>var</tt> variable to hold the iterated element's jQuery wrapper. 
     An extra <tt>var_index</tt> variable is defined
     to hold the current iteration number.
    ~{/doc}
  </script>
  <h3>jQuery</h3>
  <p>
   Iterate over jQuery selectors with the <tt>jQuery</tt> tag.
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}<ul>
 ~{jQuery selector: "h2", var: "header"}
  <li>^{header_index}: ^{header.text()}</li>
 ~{/jQuery}
</ul>~{/noEval}~{/example}
  </script>

  <script data-jstemplate="inline" type="text/html">
    ~{doc tag: 'timer', 
          attribute: 'an integer expression defining the number of milliseconds for each update', 
          body: true}
     Evaluates the body and re-evaluates it every <tt>X</tt> milliseconds.
    ~{/doc}
  </script>
  <h3>timer</h3>
  <p>
   Refresh parts of your document every <tt>X</tt> milliseconds with the <tt>timer</tt> tag.
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}~{timer 5000}
^{new Date().toLocaleString()}
~{/timer}~{/noEval}~{/example}
  </script>

  <script data-jstemplate="inline" type="text/html">
    ~{doc tag: 'future', 
          attribute: 'an Future instance holding a reference to data that will become available asynchronously', 
          body: true}
     Evaluates the body when the Future instance data is ready, possibly asynchronously if it is not ready yet.
    ~{/doc}
  </script>
  <h3>future</h3>
  <p>
   The <tt>future</tt> tag allows you to delay template evaluation until the given <tt>Future</tt> is defined.
  </p>
  <p>
   When doing AJAX it's likely you'll have some templates that will depend on external data which you
   load using AJAX, which means it's going to be asynchronous.
  </p>
  <p>
   In JSTemplates we use <i>futures</i> to describe values that might or might not yet be defined 
   (because they could arrive later via AJAX). When you pass the <tt>future</tt> tag a value which is 
   an instance of the type <tt>JSTemplates.Future</tt>, the current template tag evaluation is delayed 
   until the <i>future</i> instance is defined fully (when it receives its value from the network, 
   for instance), and the current template is <i>partially</i> evaluated, leaving gaps
   (actually, placeholders) where the template tags are waiting for <i>futures</i>.
  </p>
  <p>
   Once the <i>future</i> instances are complete, the template processing is resumed with the 
   <i>future</i>'s value and the placeholders are replaced with the evaluation of the delayed templates.
  </p>
  <p>
   This makes it very easy to define a complete page with <i>holes</i> for the parts which rely on external data,
   without delaying the rendering of the rest of the templates.
  </p>
  <p>
   You can define a <i>future</i> which gets JSON data from an external source like this:
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{noEval}~{future 
   value:new JSTemplates.Future("/Application/data"), 
   var:'elements' }
 <ul>
 ~{list items: elements, var: 'v'}
  <li>Value of v is: ^{v}</li>
 ~{/list}
 </ul>
~{/future}~{/noEval}~{/example}
  </script>

  <script data-jstemplate="inline" type="text/html">
    ~{doc tag: 'noEval', 
          body: true}
     Outputs the body with no JSTemplate interpretation. Use this if you want to output code that would
     otherwise be intepreted as JSTemplate.
    ~{/doc}
  </script>
  <h3>noEval</h3>
  <p>
   Output non-evaluated template code with the <tt>noEval</tt> tag.
  </p>
  <script data-jstemplate="inline" type="text/html">
   ~{example}~{openTag 'noEval'/}~{noEval}
^{new Date().toLocaleString()}
~{/noEval}~{closeTag 'noEval'/}~{/example}
  </script>
 </div>
</div>

<div class="para">
 <h2 class="title">Writing new tags</h2>
 <div class="body">
  <h3>Simple tags</h3>
  <p>
   Define your simple tags with <tt>script</tt> elements of type <tt>text/html</tt>, the <tt>data-jstemplate</tt> 
   attribute set to <tt>tag</tt> and the <tt>name</tt> attribute to set the name of the new simple tag.
  </p>
  <p>
   The simple tag's attributes are prefixed with a "<tt>_</tt>", and if there is a default attribute it is available
   as <tt>_arg</tt>. You can refer to the tag's body with <tt>~{doBody/}</tt>:
  </p>
  <table class="example">
   <tr>
    <th class="program">HTML</th>
    <th>Example</th>
   </tr>
   <tr>
   <td class="program">
    <code><pre>&lt;script type="text/html" data-jstemplate="tag" name="foo">
 Default argument: ^{_arg}&ltbr/>
 Named argument: ^{_item}&ltbr/>
 Body: ~{doBody/}
&lt;/script>
</pre></code>
   </td>
   <td class="result">
<code><pre>
 ~{foo 'default arg goes here'}Body goes there~{/foo}
 ~{foo item: 'named arg goes here'/}
</pre></code>
   </td>
  </tr>
 </table>
  
  <h3>Programmatically</h3>
  <p>
   You must define a subtype of <tt>JSTemplates.Tag</tt>, and register it in JSTemplates so it can find it:
  </p>
  <table class="example">
   <tr>
    <th class="program">HTML</th>
   </tr>
   <tr>
   <td class="program">
    <code><pre>&lt;script type="text/javascript">
 // define our new tag type
 function HelloTag(name, attributes){
	JSTemplates.Tag.apply(this, [name, attributes]);
 }
 // make sure it inherits methods from JSTemplates.Tag
 JSTemplates.extend(HelloTag, JSTemplates.Tag);

 // and implement its behaviour
 HelloTag.prototype.outputInNewEnv = function(out, previousSibling, env){
	// when we do not name the attributes, the default is "_arg"
	// we evaluate the contents of the attribute in the current environment
	var string = env.evalExpression(this.attributes._arg);
	// and we write it out
	out('Hello ' + string);
 };

 // register this new tag in JSTemplates
 JSTemplates.declareTag('hello', HelloTag);
&lt;/script>
</pre></code>
   </td>
   </tr>
  </table>

  <h3>Loading templates from the network</h3>
  <p>
   You can load simple tags from the network, just like you can load JavaScript and CSS, by placing them into
   a file and adding the following <tt>link</tt> elements to your document <tt>head</tt>:
  </p>
  <table class="example">
   <tr>
    <th class="program">HTML</th>
   </tr>
   <tr>
   <td class="program">
    <code><pre>&lt;link rel="jstemplates" href="/templates/my-tags.html" type="text/html" /></pre></code>
   </td>
   </tr>
  </table>
 </div>
</div>

<div class="para">
 <h2 class="title">API</h2>
 <div class="body">
  <h3>Invoking functions when JSTemplates is ready</h3>
  <p>
   Sometimes you need to invoke some code when all templates have been executed, and <tt>body.onload</tt> or
   <tt>jQuery(f)</tt> is not enough, but you can register your initialisation code with:
  </p>
  <code><pre>JSTemplates.ready(function(){ alert('It is ready!'); });</pre></code>
 </div>
</div>
